pub fn create_graph_from_data(categories: Vec<Category>, edges: Vec<(usize, usize)>) -> Graph<Category, ()> {
    let mut graph = Graph::<Category, ()>::new();

    // Add nodes to the graph from the category data
    let mut nodes = HashMap::new();
    for (index, category) in categories.into_iter().enumerate() {
        let node_index = graph.add_node(category);
        nodes.insert(index, node_index);
    }

    // Add edges to the graph using the given indices
    for (source, target) in edges {
        if let (Some(&source_node), Some(&target_node)) = (nodes.get(&source), nodes.get(&target)) {
            graph.add_edge(source_node, target_node, ());
        }
    }

    graph
}



// Function to summarize data by category
pub fn summarize_by_category(graph: &Graph<Category, ()>) {
    let mut category_summary: HashMap<String, (usize, f64)> = HashMap::new();

    for node_index in graph.node_indices() {
        let category_name = &graph[node_index].name;
        let neighbors_count = graph.neighbors(node_index).count();

        category_summary.entry(category_name.clone()).or_insert((0, 0.0)).0 += neighbors_count;
    }

    let total_nodes = graph.node_count();
    let mut updated_summary: HashMap<String, (usize, f64)> = HashMap::new();
    for (category, (total_neighbors, _)) in &category_summary {
        let average_degree_centrality = *total_neighbors as f64 / total_nodes as f64;
        updated_summary.insert(category.clone(), (*total_neighbors, average_degree_centrality));
    }

    for (category, (neighbors, avg_centrality)) in &updated_summary {
        println!("Category: {}, Total Neighbors: {}, Average Degree Centrality: {:.2}", category, neighbors, avg_centrality);
    }
}
pub fn save_clean_data(&self, output_filepath: &str) -> Result<(), Box<dyn Error>> {
    let serialized_data = serde_json::to_string(&self.data)?;
    fs::write(output_filepath, serialized_data)?;
    Ok(())
}



pub fn summarize_by_category(&self, min_products: usize) {
    // Step 1: Count the number of products in each category
    let mut category_counts: HashMap<String, usize> = HashMap::new();
    for product in &self.data {
        if let Some(category) = product.group.clone() {
            *category_counts.entry(category).or_insert(0) += 1;
        }
    }

    // Step 2: Filter categories with more than `min_products` products
    let filtered_categories: Vec<_> = category_counts
        .iter()
        .filter(|&(_, &count)| count >= min_products)
        .collect();

    // Step 3: Calculate summary statistics for each category
    for (category, &count) in filtered_categories {
        let products_in_category: Vec<_> = self
            .data
            .iter()
            .filter(|p| p.group.as_ref() == Some(category))
            .collect();

        let avg_sales_rank: f64 = products_in_category
            .iter()
            .filter_map(|p| p.salesrank)
            .map(|r| r as f64)
            .sum::<f64>()
            / count as f64;

        let avg_rating: f64 = products_in_category
            .iter()
            .flat_map(|p| p.reviews.iter())
            .map(|r| r.rating as f64)
            .sum::<f64>()
            / products_in_category
                .iter()
                .flat_map(|p| p.reviews.iter())
                .count() as f64;

        println!("Category: {}", category);
        println!("  Number of Products: {}", count);
        println!("  Average Sales Rank: {:.2}", avg_sales_rank);
        if avg_rating.is_nan() {
            println!("  Average Review Rating: No reviews available");
        } else {
            println!("  Average Review Rating: {:.2}", avg_rating);
        }
    }
}


pub fn create_graphs_for_top_categories(&self, top_categories: Vec<(String, usize, f64, Option<f64>)>,) -> HashMap<String, Graph<u32, ()>>{
    println!("ASINs in dataset:");
    for product in &self.data {
        if let Some(asin) = &product.asin {
            println!("{}", asin); // List all ASINs to compare with `similar`
        }
    }

    let mut category_graphs = HashMap::new();

    for (category, _, _, _) in top_categories{
        let mut graph = Graph::<u32, ()>::new();
        let mut id_to_node = HashMap::new();

        let products_in_category: Vec<_> = self
        .data
        .iter()
        .filter(|p| p.group.as_ref() == Some(&category))
        .collect();

        for product in &products_in_category{
            let node_index = graph.add_node(product.id);
            id_to_node.insert(product.id, node_index);
        }

        for product in &products_in_category{
            if let Some(&node) = id_to_node.get(&product.id){
                for similar_asin in &product.similar{
                    if let Some(similar_product) = self
                        .data
                        .iter()
                        .find(|p| p.asin.as_deref() == Some(similar_asin))
                    {
                        if let Some(&similiar_node) = id_to_node.get(&similar_product.id){
                            graph.add_edge(node, similiar_node, ());
                        }
                    }
                }
            }
        }

        category_graphs.insert(category, graph);
    }
    category_graphs

}


for similar_asin in &product.similar {
    let similar_asin_normalized = similar_asin.trim().to_lowercase(); // Normalize similar ASIN
    if let Some(similar_product) = self
        .data
        .iter()
        .find(|p| p.asin.as_deref().map(|a| a.trim().to_lowercase()) == Some(similar_asin_normalized.clone()))
    {
        if let Some(&similar_node) = id_to_node.get(&similar_product.id) {
            graph.add_edge(node, similar_node, ()); // Add edge
        }
    }
}
